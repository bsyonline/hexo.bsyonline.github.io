---
title: Understanding Design with Idempotency
tags:
  - Interview
category:
  - Architecture
author: bsyonline
lede: 没有摘要
date: 2019-07-31 21:21:40
thumbnail:
---



幂等设计是架构设计中需要考虑的重要环节。幂等设计可以分两个层面考虑：请求幂等和业务幂等。

#### 请求幂等

​	所谓请求幂等，就是请求一次和请求多次结果一样。其实这个说法有一点不准确，因为如果是看请求结果的话，那么在读请求在数据被修改之后，得到的结果也是不同的。所以准确的说应该是看请求是否有副作用，比如每次请求都会将数据修改成不一样的值。按照这个定义，读请求不会修改数据本身，所以读请求是幂等的。而写请求是会修改数据本身的，所以写请求不是幂等的。由于写请求不是天然幂等的，所以我们在架构设计的时候需要针对写请求进行幂等处理。

​	由于请求最终都是操作数据库，所以最终都会反映到数据库的CRUD操作。select 是读操作，所以是天然幂等的。剩下的增删改都不是天然幂等，我们应该如何处理呢？

**Create**

虽然 Create 操作不是幂等操作，但是在下面一些情况下是可以做到幂等的：

1. 使用业务主键
2. 使用逻辑主键+唯一索引

业务主键不是在数据库中生成的，在插入记录的时候，业务主键已经生成了，所以只要业务主键不变，由于主键约束，执行多次结果是相同的。逻辑主键虽然是数据库生成的，但是由于有其他的业务字段做唯一约束，所以也是可以做到幂等的。

**Update**

Update 操作可分为绝对值更新和相对值更新。```update t1 set age=20 where id=1``` 对于这类的更新叫做绝对值的更新，可以看到，不论执行多少次结果都是一样的，这样是可以保证幂等的。```update t1 set age++ where id=1``` 同样是更新操作，相对值的更新多次执行结果是不同的，所以不是幂等的。因此，对于相对值的更新，我们可以把它转化成绝对值的修改。有如下几种方式：

1. 使用乐观锁。可以引入 version 字段，先获得 version，然后在更新 ```update t1 set age++, version++ where id=1 and version=1``` 。当然 version 并不是必须的，使用业务字段代替 version 可以达到相同的效果 ```update t1 set age++ where id=1 and age=20``` 。
2. 先查到 id=1 的 age，然后在上层将相对值修改成绝对值。

**Delete**

Delete 操作和 Update 操作类似，同样可以通过相对值和绝对值的转换达到幂等的效果。

通过上面的分析，我们可以通过转化，将非幂等的操作转化成幂等操作，保证数据的正确性。那是不是这样做就一定不会出问题呢？我们可以考虑一个场景。在一个多层的微服务架构中，进行下订单操作。通过使用订单号作为业务主键，可以保证数据层的操作是幂等的。因为订单号是在业务层层生成的，那么不论业务层对数据层重试，都不会出问题。但是，如果我们在网关层调服务层的时候进行重试，就会出现多下订单的问题。那么这样的情况下应该如何处理呢？

1. 不允许重试，不过这样好像不太优雅。
2. 我们可以将生成订单号的操作提前，比如放到网关层。但是如果 nginx 调网关层发生重试，也会造成多下单的情况。为了防止这种情况，我们需要把生成订单号的操作放到 nginx 。但是同样会出现客户端重试的问题，所以最终就是把生成订单号的操作放到客户端，但是这样就必须考虑安全方面的问题。
3. 使用固定规则，比如 hash(用户id+商品id) ，只要信息不变，在任何地方生成 id 的值都是相同的。
4. 使用共享 id 的方式。比如将用户 id 和订单号放到 redis 里，每次先从 redis 中获取。

虽然我们列出几种出里方式，但是并没有一种方式是完美的，需要根据业务和架构进行选择。

#### 业务幂等

